// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stt.proto

#ifndef PROTOBUF_INCLUDED_stt_2eproto
#define PROTOBUF_INCLUDED_stt_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_stt_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_stt_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_stt_2eproto();
namespace SpeechToText {
class ConfigResult;
class ConfigResultDefaultTypeInternal;
extern ConfigResultDefaultTypeInternal _ConfigResult_default_instance_;
class ConfigSTT;
class ConfigSTTDefaultTypeInternal;
extern ConfigSTTDefaultTypeInternal _ConfigSTT_default_instance_;
class SpeechChunk;
class SpeechChunkDefaultTypeInternal;
extern SpeechChunkDefaultTypeInternal _SpeechChunk_default_instance_;
class TranscriptChunk;
class TranscriptChunkDefaultTypeInternal;
extern TranscriptChunkDefaultTypeInternal _TranscriptChunk_default_instance_;
}  // namespace SpeechToText
namespace google {
namespace protobuf {
template<> ::SpeechToText::ConfigResult* Arena::CreateMaybeMessage<::SpeechToText::ConfigResult>(Arena*);
template<> ::SpeechToText::ConfigSTT* Arena::CreateMaybeMessage<::SpeechToText::ConfigSTT>(Arena*);
template<> ::SpeechToText::SpeechChunk* Arena::CreateMaybeMessage<::SpeechToText::SpeechChunk>(Arena*);
template<> ::SpeechToText::TranscriptChunk* Arena::CreateMaybeMessage<::SpeechToText::TranscriptChunk>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace SpeechToText {

// ===================================================================

class ConfigSTT final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SpeechToText.ConfigSTT) */ {
 public:
  ConfigSTT();
  virtual ~ConfigSTT();

  ConfigSTT(const ConfigSTT& from);

  inline ConfigSTT& operator=(const ConfigSTT& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigSTT(ConfigSTT&& from) noexcept
    : ConfigSTT() {
    *this = ::std::move(from);
  }

  inline ConfigSTT& operator=(ConfigSTT&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConfigSTT& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigSTT* internal_default_instance() {
    return reinterpret_cast<const ConfigSTT*>(
               &_ConfigSTT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ConfigSTT* other);
  friend void swap(ConfigSTT& a, ConfigSTT& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigSTT* New() const final {
    return CreateMaybeMessage<ConfigSTT>(nullptr);
  }

  ConfigSTT* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigSTT>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigSTT& from);
  void MergeFrom(const ConfigSTT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigSTT* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string asrs = 1;
  int asrs_size() const;
  void clear_asrs();
  static const int kAsrsFieldNumber = 1;
  const ::std::string& asrs(int index) const;
  ::std::string* mutable_asrs(int index);
  void set_asrs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_asrs(int index, ::std::string&& value);
  #endif
  void set_asrs(int index, const char* value);
  void set_asrs(int index, const char* value, size_t size);
  ::std::string* add_asrs();
  void add_asrs(const ::std::string& value);
  #if LANG_CXX11
  void add_asrs(::std::string&& value);
  #endif
  void add_asrs(const char* value);
  void add_asrs(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& asrs() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_asrs();

  // string encoding = 2;
  void clear_encoding();
  static const int kEncodingFieldNumber = 2;
  const ::std::string& encoding() const;
  void set_encoding(const ::std::string& value);
  #if LANG_CXX11
  void set_encoding(::std::string&& value);
  #endif
  void set_encoding(const char* value);
  void set_encoding(const char* value, size_t size);
  ::std::string* mutable_encoding();
  ::std::string* release_encoding();
  void set_allocated_encoding(::std::string* encoding);

  // string language = 4;
  void clear_language();
  static const int kLanguageFieldNumber = 4;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // int32 sampling_rate = 3;
  void clear_sampling_rate();
  static const int kSamplingRateFieldNumber = 3;
  ::google::protobuf::int32 sampling_rate() const;
  void set_sampling_rate(::google::protobuf::int32 value);

  // int32 max_alternatives = 5;
  void clear_max_alternatives();
  static const int kMaxAlternativesFieldNumber = 5;
  ::google::protobuf::int32 max_alternatives() const;
  void set_max_alternatives(::google::protobuf::int32 value);

  // bool profanity_filter = 6;
  void clear_profanity_filter();
  static const int kProfanityFilterFieldNumber = 6;
  bool profanity_filter() const;
  void set_profanity_filter(bool value);

  // bool interim_results = 7;
  void clear_interim_results();
  static const int kInterimResultsFieldNumber = 7;
  bool interim_results() const;
  void set_interim_results(bool value);

  // bool continuous = 8;
  void clear_continuous();
  static const int kContinuousFieldNumber = 8;
  bool continuous() const;
  void set_continuous(bool value);

  // int32 chunksize = 9;
  void clear_chunksize();
  static const int kChunksizeFieldNumber = 9;
  ::google::protobuf::int32 chunksize() const;
  void set_chunksize(::google::protobuf::int32 value);

  // int32 inactivity = 10;
  void clear_inactivity();
  static const int kInactivityFieldNumber = 10;
  ::google::protobuf::int32 inactivity() const;
  void set_inactivity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SpeechToText.ConfigSTT)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> asrs_;
  ::google::protobuf::internal::ArenaStringPtr encoding_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::int32 sampling_rate_;
  ::google::protobuf::int32 max_alternatives_;
  bool profanity_filter_;
  bool interim_results_;
  bool continuous_;
  ::google::protobuf::int32 chunksize_;
  ::google::protobuf::int32 inactivity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stt_2eproto;
};
// -------------------------------------------------------------------

class ConfigResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SpeechToText.ConfigResult) */ {
 public:
  ConfigResult();
  virtual ~ConfigResult();

  ConfigResult(const ConfigResult& from);

  inline ConfigResult& operator=(const ConfigResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigResult(ConfigResult&& from) noexcept
    : ConfigResult() {
    *this = ::std::move(from);
  }

  inline ConfigResult& operator=(ConfigResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConfigResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigResult* internal_default_instance() {
    return reinterpret_cast<const ConfigResult*>(
               &_ConfigResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ConfigResult* other);
  friend void swap(ConfigResult& a, ConfigResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigResult* New() const final {
    return CreateMaybeMessage<ConfigResult>(nullptr);
  }

  ConfigResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigResult& from);
  void MergeFrom(const ConfigResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .SpeechToText.ConfigSTT config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::SpeechToText::ConfigSTT& config() const;
  ::SpeechToText::ConfigSTT* release_config();
  ::SpeechToText::ConfigSTT* mutable_config();
  void set_allocated_config(::SpeechToText::ConfigSTT* config);

  // bool status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // @@protoc_insertion_point(class_scope:SpeechToText.ConfigResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::SpeechToText::ConfigSTT* config_;
  bool status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stt_2eproto;
};
// -------------------------------------------------------------------

class SpeechChunk final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SpeechToText.SpeechChunk) */ {
 public:
  SpeechChunk();
  virtual ~SpeechChunk();

  SpeechChunk(const SpeechChunk& from);

  inline SpeechChunk& operator=(const SpeechChunk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeechChunk(SpeechChunk&& from) noexcept
    : SpeechChunk() {
    *this = ::std::move(from);
  }

  inline SpeechChunk& operator=(SpeechChunk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SpeechChunk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeechChunk* internal_default_instance() {
    return reinterpret_cast<const SpeechChunk*>(
               &_SpeechChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SpeechChunk* other);
  friend void swap(SpeechChunk& a, SpeechChunk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeechChunk* New() const final {
    return CreateMaybeMessage<SpeechChunk>(nullptr);
  }

  SpeechChunk* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeechChunk>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeechChunk& from);
  void MergeFrom(const SpeechChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechChunk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // string token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // .SpeechToText.ConfigSTT config = 3;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  const ::SpeechToText::ConfigSTT& config() const;
  ::SpeechToText::ConfigSTT* release_config();
  ::SpeechToText::ConfigSTT* mutable_config();
  void set_allocated_config(::SpeechToText::ConfigSTT* config);

  // @@protoc_insertion_point(class_scope:SpeechToText.SpeechChunk)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::SpeechToText::ConfigSTT* config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stt_2eproto;
};
// -------------------------------------------------------------------

class TranscriptChunk final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SpeechToText.TranscriptChunk) */ {
 public:
  TranscriptChunk();
  virtual ~TranscriptChunk();

  TranscriptChunk(const TranscriptChunk& from);

  inline TranscriptChunk& operator=(const TranscriptChunk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TranscriptChunk(TranscriptChunk&& from) noexcept
    : TranscriptChunk() {
    *this = ::std::move(from);
  }

  inline TranscriptChunk& operator=(TranscriptChunk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TranscriptChunk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TranscriptChunk* internal_default_instance() {
    return reinterpret_cast<const TranscriptChunk*>(
               &_TranscriptChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TranscriptChunk* other);
  friend void swap(TranscriptChunk& a, TranscriptChunk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TranscriptChunk* New() const final {
    return CreateMaybeMessage<TranscriptChunk>(nullptr);
  }

  TranscriptChunk* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TranscriptChunk>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TranscriptChunk& from);
  void MergeFrom(const TranscriptChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscriptChunk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string asr = 1;
  void clear_asr();
  static const int kAsrFieldNumber = 1;
  const ::std::string& asr() const;
  void set_asr(const ::std::string& value);
  #if LANG_CXX11
  void set_asr(::std::string&& value);
  #endif
  void set_asr(const char* value);
  void set_asr(const char* value, size_t size);
  ::std::string* mutable_asr();
  ::std::string* release_asr();
  void set_allocated_asr(::std::string* asr);

  // string transcript = 2;
  void clear_transcript();
  static const int kTranscriptFieldNumber = 2;
  const ::std::string& transcript() const;
  void set_transcript(const ::std::string& value);
  #if LANG_CXX11
  void set_transcript(::std::string&& value);
  #endif
  void set_transcript(const char* value);
  void set_transcript(const char* value, size_t size);
  ::std::string* mutable_transcript();
  ::std::string* release_transcript();
  void set_allocated_transcript(::std::string* transcript);

  // bool is_final = 3;
  void clear_is_final();
  static const int kIsFinalFieldNumber = 3;
  bool is_final() const;
  void set_is_final(bool value);

  // float confidence = 4;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:SpeechToText.TranscriptChunk)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asr_;
  ::google::protobuf::internal::ArenaStringPtr transcript_;
  bool is_final_;
  float confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stt_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConfigSTT

// repeated string asrs = 1;
inline int ConfigSTT::asrs_size() const {
  return asrs_.size();
}
inline void ConfigSTT::clear_asrs() {
  asrs_.Clear();
}
inline const ::std::string& ConfigSTT::asrs(int index) const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.asrs)
  return asrs_.Get(index);
}
inline ::std::string* ConfigSTT::mutable_asrs(int index) {
  // @@protoc_insertion_point(field_mutable:SpeechToText.ConfigSTT.asrs)
  return asrs_.Mutable(index);
}
inline void ConfigSTT::set_asrs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.asrs)
  asrs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ConfigSTT::set_asrs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.asrs)
  asrs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ConfigSTT::set_asrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  asrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SpeechToText.ConfigSTT.asrs)
}
inline void ConfigSTT::set_asrs(int index, const char* value, size_t size) {
  asrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SpeechToText.ConfigSTT.asrs)
}
inline ::std::string* ConfigSTT::add_asrs() {
  // @@protoc_insertion_point(field_add_mutable:SpeechToText.ConfigSTT.asrs)
  return asrs_.Add();
}
inline void ConfigSTT::add_asrs(const ::std::string& value) {
  asrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SpeechToText.ConfigSTT.asrs)
}
#if LANG_CXX11
inline void ConfigSTT::add_asrs(::std::string&& value) {
  asrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SpeechToText.ConfigSTT.asrs)
}
#endif
inline void ConfigSTT::add_asrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  asrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SpeechToText.ConfigSTT.asrs)
}
inline void ConfigSTT::add_asrs(const char* value, size_t size) {
  asrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SpeechToText.ConfigSTT.asrs)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ConfigSTT::asrs() const {
  // @@protoc_insertion_point(field_list:SpeechToText.ConfigSTT.asrs)
  return asrs_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
ConfigSTT::mutable_asrs() {
  // @@protoc_insertion_point(field_mutable_list:SpeechToText.ConfigSTT.asrs)
  return &asrs_;
}

// string encoding = 2;
inline void ConfigSTT::clear_encoding() {
  encoding_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConfigSTT::encoding() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.encoding)
  return encoding_.GetNoArena();
}
inline void ConfigSTT::set_encoding(const ::std::string& value) {
  
  encoding_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.encoding)
}
#if LANG_CXX11
inline void ConfigSTT::set_encoding(::std::string&& value) {
  
  encoding_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpeechToText.ConfigSTT.encoding)
}
#endif
inline void ConfigSTT::set_encoding(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  encoding_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpeechToText.ConfigSTT.encoding)
}
inline void ConfigSTT::set_encoding(const char* value, size_t size) {
  
  encoding_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpeechToText.ConfigSTT.encoding)
}
inline ::std::string* ConfigSTT::mutable_encoding() {
  
  // @@protoc_insertion_point(field_mutable:SpeechToText.ConfigSTT.encoding)
  return encoding_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfigSTT::release_encoding() {
  // @@protoc_insertion_point(field_release:SpeechToText.ConfigSTT.encoding)
  
  return encoding_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigSTT::set_allocated_encoding(::std::string* encoding) {
  if (encoding != nullptr) {
    
  } else {
    
  }
  encoding_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encoding);
  // @@protoc_insertion_point(field_set_allocated:SpeechToText.ConfigSTT.encoding)
}

// int32 sampling_rate = 3;
inline void ConfigSTT::clear_sampling_rate() {
  sampling_rate_ = 0;
}
inline ::google::protobuf::int32 ConfigSTT::sampling_rate() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.sampling_rate)
  return sampling_rate_;
}
inline void ConfigSTT::set_sampling_rate(::google::protobuf::int32 value) {
  
  sampling_rate_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.sampling_rate)
}

// string language = 4;
inline void ConfigSTT::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConfigSTT::language() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.language)
  return language_.GetNoArena();
}
inline void ConfigSTT::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.language)
}
#if LANG_CXX11
inline void ConfigSTT::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpeechToText.ConfigSTT.language)
}
#endif
inline void ConfigSTT::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpeechToText.ConfigSTT.language)
}
inline void ConfigSTT::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpeechToText.ConfigSTT.language)
}
inline ::std::string* ConfigSTT::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:SpeechToText.ConfigSTT.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfigSTT::release_language() {
  // @@protoc_insertion_point(field_release:SpeechToText.ConfigSTT.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigSTT::set_allocated_language(::std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:SpeechToText.ConfigSTT.language)
}

// int32 max_alternatives = 5;
inline void ConfigSTT::clear_max_alternatives() {
  max_alternatives_ = 0;
}
inline ::google::protobuf::int32 ConfigSTT::max_alternatives() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.max_alternatives)
  return max_alternatives_;
}
inline void ConfigSTT::set_max_alternatives(::google::protobuf::int32 value) {
  
  max_alternatives_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.max_alternatives)
}

// bool profanity_filter = 6;
inline void ConfigSTT::clear_profanity_filter() {
  profanity_filter_ = false;
}
inline bool ConfigSTT::profanity_filter() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.profanity_filter)
  return profanity_filter_;
}
inline void ConfigSTT::set_profanity_filter(bool value) {
  
  profanity_filter_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.profanity_filter)
}

// bool interim_results = 7;
inline void ConfigSTT::clear_interim_results() {
  interim_results_ = false;
}
inline bool ConfigSTT::interim_results() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.interim_results)
  return interim_results_;
}
inline void ConfigSTT::set_interim_results(bool value) {
  
  interim_results_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.interim_results)
}

// bool continuous = 8;
inline void ConfigSTT::clear_continuous() {
  continuous_ = false;
}
inline bool ConfigSTT::continuous() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.continuous)
  return continuous_;
}
inline void ConfigSTT::set_continuous(bool value) {
  
  continuous_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.continuous)
}

// int32 chunksize = 9;
inline void ConfigSTT::clear_chunksize() {
  chunksize_ = 0;
}
inline ::google::protobuf::int32 ConfigSTT::chunksize() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.chunksize)
  return chunksize_;
}
inline void ConfigSTT::set_chunksize(::google::protobuf::int32 value) {
  
  chunksize_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.chunksize)
}

// int32 inactivity = 10;
inline void ConfigSTT::clear_inactivity() {
  inactivity_ = 0;
}
inline ::google::protobuf::int32 ConfigSTT::inactivity() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigSTT.inactivity)
  return inactivity_;
}
inline void ConfigSTT::set_inactivity(::google::protobuf::int32 value) {
  
  inactivity_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigSTT.inactivity)
}

// -------------------------------------------------------------------

// ConfigResult

// bool status = 1;
inline void ConfigResult::clear_status() {
  status_ = false;
}
inline bool ConfigResult::status() const {
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigResult.status)
  return status_;
}
inline void ConfigResult::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.ConfigResult.status)
}

// .SpeechToText.ConfigSTT config = 2;
inline bool ConfigResult::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void ConfigResult::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::SpeechToText::ConfigSTT& ConfigResult::config() const {
  const ::SpeechToText::ConfigSTT* p = config_;
  // @@protoc_insertion_point(field_get:SpeechToText.ConfigResult.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::SpeechToText::ConfigSTT*>(
      &::SpeechToText::_ConfigSTT_default_instance_);
}
inline ::SpeechToText::ConfigSTT* ConfigResult::release_config() {
  // @@protoc_insertion_point(field_release:SpeechToText.ConfigResult.config)
  
  ::SpeechToText::ConfigSTT* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::SpeechToText::ConfigSTT* ConfigResult::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpeechToText::ConfigSTT>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpeechToText.ConfigResult.config)
  return config_;
}
inline void ConfigResult::set_allocated_config(::SpeechToText::ConfigSTT* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:SpeechToText.ConfigResult.config)
}

// -------------------------------------------------------------------

// SpeechChunk

// bytes content = 1;
inline void SpeechChunk::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpeechChunk::content() const {
  // @@protoc_insertion_point(field_get:SpeechToText.SpeechChunk.content)
  return content_.GetNoArena();
}
inline void SpeechChunk::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpeechToText.SpeechChunk.content)
}
#if LANG_CXX11
inline void SpeechChunk::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpeechToText.SpeechChunk.content)
}
#endif
inline void SpeechChunk::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpeechToText.SpeechChunk.content)
}
inline void SpeechChunk::set_content(const void* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpeechToText.SpeechChunk.content)
}
inline ::std::string* SpeechChunk::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:SpeechToText.SpeechChunk.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeechChunk::release_content() {
  // @@protoc_insertion_point(field_release:SpeechToText.SpeechChunk.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechChunk::set_allocated_content(::std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:SpeechToText.SpeechChunk.content)
}

// string token = 2;
inline void SpeechChunk::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpeechChunk::token() const {
  // @@protoc_insertion_point(field_get:SpeechToText.SpeechChunk.token)
  return token_.GetNoArena();
}
inline void SpeechChunk::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpeechToText.SpeechChunk.token)
}
#if LANG_CXX11
inline void SpeechChunk::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpeechToText.SpeechChunk.token)
}
#endif
inline void SpeechChunk::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpeechToText.SpeechChunk.token)
}
inline void SpeechChunk::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpeechToText.SpeechChunk.token)
}
inline ::std::string* SpeechChunk::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:SpeechToText.SpeechChunk.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeechChunk::release_token() {
  // @@protoc_insertion_point(field_release:SpeechToText.SpeechChunk.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechChunk::set_allocated_token(::std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:SpeechToText.SpeechChunk.token)
}

// .SpeechToText.ConfigSTT config = 3;
inline bool SpeechChunk::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void SpeechChunk::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::SpeechToText::ConfigSTT& SpeechChunk::config() const {
  const ::SpeechToText::ConfigSTT* p = config_;
  // @@protoc_insertion_point(field_get:SpeechToText.SpeechChunk.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::SpeechToText::ConfigSTT*>(
      &::SpeechToText::_ConfigSTT_default_instance_);
}
inline ::SpeechToText::ConfigSTT* SpeechChunk::release_config() {
  // @@protoc_insertion_point(field_release:SpeechToText.SpeechChunk.config)
  
  ::SpeechToText::ConfigSTT* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::SpeechToText::ConfigSTT* SpeechChunk::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpeechToText::ConfigSTT>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpeechToText.SpeechChunk.config)
  return config_;
}
inline void SpeechChunk::set_allocated_config(::SpeechToText::ConfigSTT* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:SpeechToText.SpeechChunk.config)
}

// -------------------------------------------------------------------

// TranscriptChunk

// string asr = 1;
inline void TranscriptChunk::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TranscriptChunk::asr() const {
  // @@protoc_insertion_point(field_get:SpeechToText.TranscriptChunk.asr)
  return asr_.GetNoArena();
}
inline void TranscriptChunk::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpeechToText.TranscriptChunk.asr)
}
#if LANG_CXX11
inline void TranscriptChunk::set_asr(::std::string&& value) {
  
  asr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpeechToText.TranscriptChunk.asr)
}
#endif
inline void TranscriptChunk::set_asr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpeechToText.TranscriptChunk.asr)
}
inline void TranscriptChunk::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpeechToText.TranscriptChunk.asr)
}
inline ::std::string* TranscriptChunk::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:SpeechToText.TranscriptChunk.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TranscriptChunk::release_asr() {
  // @@protoc_insertion_point(field_release:SpeechToText.TranscriptChunk.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranscriptChunk::set_allocated_asr(::std::string* asr) {
  if (asr != nullptr) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:SpeechToText.TranscriptChunk.asr)
}

// string transcript = 2;
inline void TranscriptChunk::clear_transcript() {
  transcript_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TranscriptChunk::transcript() const {
  // @@protoc_insertion_point(field_get:SpeechToText.TranscriptChunk.transcript)
  return transcript_.GetNoArena();
}
inline void TranscriptChunk::set_transcript(const ::std::string& value) {
  
  transcript_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpeechToText.TranscriptChunk.transcript)
}
#if LANG_CXX11
inline void TranscriptChunk::set_transcript(::std::string&& value) {
  
  transcript_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpeechToText.TranscriptChunk.transcript)
}
#endif
inline void TranscriptChunk::set_transcript(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transcript_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpeechToText.TranscriptChunk.transcript)
}
inline void TranscriptChunk::set_transcript(const char* value, size_t size) {
  
  transcript_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpeechToText.TranscriptChunk.transcript)
}
inline ::std::string* TranscriptChunk::mutable_transcript() {
  
  // @@protoc_insertion_point(field_mutable:SpeechToText.TranscriptChunk.transcript)
  return transcript_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TranscriptChunk::release_transcript() {
  // @@protoc_insertion_point(field_release:SpeechToText.TranscriptChunk.transcript)
  
  return transcript_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranscriptChunk::set_allocated_transcript(::std::string* transcript) {
  if (transcript != nullptr) {
    
  } else {
    
  }
  transcript_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transcript);
  // @@protoc_insertion_point(field_set_allocated:SpeechToText.TranscriptChunk.transcript)
}

// bool is_final = 3;
inline void TranscriptChunk::clear_is_final() {
  is_final_ = false;
}
inline bool TranscriptChunk::is_final() const {
  // @@protoc_insertion_point(field_get:SpeechToText.TranscriptChunk.is_final)
  return is_final_;
}
inline void TranscriptChunk::set_is_final(bool value) {
  
  is_final_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.TranscriptChunk.is_final)
}

// float confidence = 4;
inline void TranscriptChunk::clear_confidence() {
  confidence_ = 0;
}
inline float TranscriptChunk::confidence() const {
  // @@protoc_insertion_point(field_get:SpeechToText.TranscriptChunk.confidence)
  return confidence_;
}
inline void TranscriptChunk::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:SpeechToText.TranscriptChunk.confidence)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SpeechToText

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_stt_2eproto
